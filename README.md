- ## Iterative Approach 

    - ### Intuition
        - The problem relies on the recursive structure of binary strings generated by a specific pattern. Each string at level n consists of the previous string at level n-1, a middle bit ('1'), and an inverted (flipped) and reversed version of the previous string. This approach avoids constructing the entire string by iteratively determining the position of the k-th bit, utilizing an inversion flag to account for bit flipping as needed.

    - ### Approach
        1. **Calculate Length**: Compute the length of the n-th binary string, which is 2<sup>n</sup> - 1.
        2. **Iterative Search**: Use a while loop to find the k-th bit:
            - Determine the middle position of the current length.
            - If k is in the left half, continue searching in that half.
            - If k is in the right half, reflect k and toggle the inversion flag.
            - If k corresponds to the middle bit, return '1' or '0' based on the inversion flag.
        3. **Final Bit**: After the loop, return the final bit based on the inversion status.

    - ### Time and Space Complexity

        - __Time Complexity:__ ___O(log k)___
            
            - The while loop reduces the problem size by half in each iteration, leading to logarithmic complexity.

        - __Space Complexity:__ ___O(1)___
            
            - The space used is constant, as no additional data structures are employed beyond a few variables.

    - ### Code
        ```python
        class Solution:
            def findKthBit(self, n: int, k: int) -> str:
                # Calculate the length of the n-th binary string
                length = 2**n - 1
                invert = False  # Flag to track if we need to invert the bit

                # Iteratively determine the k-th bit
                while length > 1:
                    half = length // 2  # Find the position of the middle bit

                    if k <= half:
                        length = half  # Move to the left half
                    elif k > half + 1:
                        k = 1 + length - k  # Reflect k for the right half
                        length = half
                        invert = not invert  # Toggle the invert flag
                    else:
                        return '1' if not invert else '0'  # Return the middle bit

                return '0' if not invert else '1'  # Return the final result based on invert flag
        ```